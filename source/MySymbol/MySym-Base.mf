
mode_setup;

% mf2pt1 support

if known ps_output:
  input findoutl;
  pencircle      := mfplain_pencircle;
  let filldraw   := mfplain_filldraw;
  let unfilldraw := mfplain_unfilldraw;
fi;

define_pixels(u, asc_height, desc_depth, delim_height, x_height);
define_whole_pixels(dot_size, small_op_size, med_op_size, large_op_size, plus_size,
  order_width, equal_spread, greater_spread,
  arrow_horiz_len, arrow_vert_len, arrow_diag_len, arrow_spread);

math_axis      := good.y(math_axis# * hppp);
rule_thickness := ceiling(rule_thickness# * hppp);
side_bearing   := ceiling(side_bearing# * hppp);
stroke_through_thickness_factor := 2/3;
stroke_through_thickness := stroke_through_thickness_factor*rule_thickness;

pickup pencircle scaled rule_thickness;
rule_pen := savepen;
pickup pencircle scaled stroke_through_thickness;
stroke_pen := savepen;

def vcentre(expr size) =
  size/2 + math_axis#, size/2 - math_axis#
enddef;

current_char := -1;

def beginsymbol(expr width, height, depth) =
  current_char := current_char + 1;
  beginchar(current_char, width, height, depth);
enddef;

def beginoperator(expr size, ratio) =
  beginsymbol(size + 2side_bearing#, vcentre(ratio * size + rule_thickness#));
    pair centre;
    centre := (w/2, (h-d)/2);
enddef;

def beginbigop(expr xscale, yscale) =
  beginsymbol(xscale * 3/2order_width# + 2side_bearing#,
              ((yscale - 1)/2 + 1) * asc_height# + yscale * 1/6equal_spread# + 2/3rule_thickness#,
              (yscale - 1)/2 * asc_height# + yscale * 1/6equal_spread# + 2/3rule_thickness#);
    pair centre;
    centre := (w/2, (h-d)/2);
    op_width  := xscale * 3/2order_width;
    op_height := yscale * (asc_height + 1/3equal_spread);
enddef;

def beginsquarebigop(expr xscale, yscale) =
  beginsymbol(xscale * (asc_height# + 1/3equal_spread#) + 2side_bearing#,
              ((yscale - 1)/2 + 1) * asc_height# + yscale * 1/6equal_spread# + 2/3rule_thickness#,
              (yscale - 1)/2 * asc_height# + yscale * 1/6equal_spread# + 2/3rule_thickness#);
    pair centre;
    centre := (w/2, (h-d)/2);
    op_width  := xscale * (asc_height + 1/3equal_spread);
    op_height := yscale * (asc_height + 1/3equal_spread);
enddef;

def beginarrow(expr angle, scale, spread) =
  arrow_len# := scale *
    if     angle mod 180 =  0: arrow_horiz_len#
    elseif angle mod 180 = 90: arrow_vert_len#
    else:                      arrow_diag_len#
    fi;
  arrow_len := scale *
    if     angle mod 180 =  0: arrow_horiz_len
    elseif angle mod 180 = 90: arrow_vert_len
    else:                      arrow_diag_len
    fi;

  beginsymbol(arrow_len# * abs (cosd (angle)) + spread * abs (sind (angle)) + 2side_bearing#,
      vcentre(arrow_len# * abs (sind (angle)) + spread * abs (cosd (angle)) + rule_thickness#));

    pair centre, head, foot;

    centre := (w/2, (h-d)/2);
    head   := centre + arrow_len/2 * dir angle;
    foot   := centre - arrow_len/2 * dir angle;
    arrow_dir := angle;
enddef;

def beginorder(expr sign, width, spread) =
  beginsymbol(width + 2u#, vcentre(spread));

    pair centre, left_point, right_point;

    centre   := (w/2, (h-d)/2);

    left_point   := centre - sign * (w/2 - u - 1/2rule_thickness) * right;
    right_point  := centre + sign * (w/2 - u - 1/2rule_thickness) * right;
enddef;

vardef stroke text t =
  forsuffixes e = l, r:
    path_.e := t;
  endfor
  path_.l -- reverse path_.r -- cycle
enddef;

% paths

def triangle(expr centre, size, angle) =
  (centre + size * dir angle) --
  (centre + size * dir (angle + 120)) --
  (centre + size * dir (angle + 240)) --
  cycle
enddef;

def square(expr centre, size, angle) =
  (centre + sqrt(2) * size * dir (angle +  45)) --
  (centre + sqrt(2) * size * dir (angle + 135)) --
  (centre + sqrt(2) * size * dir (angle + 225)) --
  (centre + sqrt(2) * size * dir (angle + 315)) --
  cycle
enddef;

def circle(expr centre, radius) =
  (centre + radius * dir   0){dir  90} ...
  (centre + radius * dir  45){dir 135} ...
  (centre + radius * dir  90){dir 180} ...
  (centre + radius * dir 135){dir 225} ...
  (centre + radius * dir 180){dir 270} ...
  (centre + radius * dir 225){dir 315} ...
  (centre + radius * dir 270){dir   0} ...
  (centre + radius * dir 315){dir  45} ...
  cycle
enddef;

def ellipse(expr centre, rad_a, rad_b, alpha) =
  (centre + rad_a * dir alpha){dir (alpha +  90)} ...
  (centre + 1/2sqrt 2 * rad_a * dir alpha + 1/2sqrt 2 * rad_b * dir (alpha + 90)){dir (alpha + 135)} ...
  (centre + rad_b * dir (alpha +  90)){dir (alpha + 180)} ...
  (centre - 1/2sqrt 2 * rad_a * dir alpha + 1/2sqrt 2 * rad_b * dir (alpha + 90)){dir (alpha + 225)} ...
  (centre + rad_a * dir (alpha + 180)){dir (alpha + 270)} ...
  (centre - 1/2sqrt 2 * rad_a * dir alpha - 1/2sqrt 2 * rad_b * dir (alpha + 90)){dir (alpha + 315)} ...
  (centre + rad_b * dir (alpha + 270)){dir (alpha +   0)} ...
  (centre + 1/2sqrt 2 * rad_a * dir alpha - 1/2sqrt 2 * rad_b * dir (alpha + 90)){dir (alpha +  45)} ...
  cycle
enddef;

def sign(expr x) =
  if x < 0: -1 elseif x = 0: 0 else: 1 fi
enddef;

def super_ellipse_point(expr centre, rad_a, rad_b, exponent, alpha, beta) =
  begingroup
    save c, s;
    c := cosd beta;
    s := sind beta;

    (centre + sign(c) * rad_a * (abs c ** exponent) * dir alpha
            + sign(s) * rad_b * (abs s ** exponent) * dir (alpha + 90))
  endgroup
enddef;

def super_ellipse(expr centre, rad_a, rad_b, exponent, alpha) =
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha,   0) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha,  30) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha,  60) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha,  90) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha, 120) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha, 150) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha, 180) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha, 210) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha, 240) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha, 270) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha, 300) ..
  super_ellipse_point(centre, rad_a, rad_b, exponent, alpha, 330) ..
  cycle
enddef;

def half_circle(expr centre, radius, angle) =
  (centre + radius * dir (angle +   0)){dir (angle +  90)} ...
  (centre + radius * dir (angle +  45)){dir (angle + 135)} ...
  (centre + radius * dir (angle +  90)){dir (angle + 180)} ...
  (centre + radius * dir (angle + 135)){dir (angle + 225)} ...
  (centre + radius * dir (angle + 180)){dir (angle + 270)}
enddef;

def reg_poly_points(suffix $)(expr n, centre, radius, angle) =
  for i = 0 upto n-1:
    z$[i] = centre + radius * dir (angle + i/n * 360);
  endfor;
enddef;

% left half of an arrow head
def arrowhead_left(expr pos, angle, spread) =
  pos{dir (angle + 170)} ..
  {dir (angle + 130)}(pos - 3/4spread * dir angle + spread/2 * dir (angle + 90)){dir (angle - 50)} ..
  {dir (angle -  50)}(pos - 1/4spread * dir angle)
enddef;

% right half of an arrow head
def arrowhead_right(expr pos, angle, spread) =
  (pos - 1/4spread * dir angle){dir (angle - 130)} ..
  {dir (angle - 130)}(pos - 3/4spread * dir angle + spread/2 * dir (angle - 90)){dir (angle + 50)} ..
  {dir (angle +  10)}pos
enddef;

% the whole arrow head
def arrowhead(expr pos, angle, spread) =
  arrowhead_left(pos, angle, spread) & arrowhead_right(pos, angle, spread)
enddef;

% intersect the arrowhead curve with a path
def arrowhead_intersection(expr pos, angle, spread, p) =
  (p intersectionpoint
      ((pos - 3/4spread * dir angle + spread/2 * dir (angle + 90)) --
	(pos) --
	(pos - 3/4spread * dir angle + spread/2 * dir (angle - 90))));
enddef;

def stroke_through_arrow(expr pos, alpha, spread)(text angles) =
  begingroup;
    stroke_dir := arrow_dir + select(alpha/45)(angles);
    stroke_len := 1/2spread / sind (stroke_dir - arrow_dir);

    pickup stroke_pen;
    draw (pos + stroke_len * dir stroke_dir) -- (pos - stroke_len * dir stroke_dir);
  endgroup;
enddef;

def ellipse_set(suffix $,@,@@,$$) =
  % given |z$,x@,z$$|, find |y@| and |z@@|
  % such that the path |z${x@-x$,0}..z@{0,y@-y$}..{z$$-z@@}z@@|
  % is consistent with an ellipse
  % and such that the line |z@@--z$$| has a given |slope|
  alpha_ := slope * (x@ - x$);
  beta_  := y$$ - y$ - slope * (x$$ - x$);
  gamma_ := alpha_ / beta_;
  y@  - y$  = .5(beta_ - alpha_ * gamma_);
  x@@ - x$  = -2gamma_ * (x@ - x$) / (1 + gamma_ * gamma_);
  y@@ - y$$ = slope * (x@@ - x$$)
enddef;

def bulb(suffix $,$$,$$$) =
  z$$$r = z$$r;

  path_.l := z$l{x$$r - x$r, 0} ... {0, y$$r - y$r}z$$l;

  filldraw path_.l -- z$$r{0, y$r - y$$r} ... {x$r - x$$r, 0}z$r -- cycle; % link

  path_.r := z$$$l{0, y$r - y$$r} .. z$$$r{0, y$$r - y$r}; % near-circle

  filldraw subpath(0, xpart(path_.r intersectiontimes path_.l)) of path_.r
        -- z$$r{0, y$$r - y$r} .. cycle; % bulb
enddef;

vardef super_arc.r(suffix $,$$) =
  % outside of super-ellipse

  pair center, corner;

  if y$ = y$r:
    center = (x$$r, y$r);
    corner = (x$r, y$$r);
  else:
    center = (x$r, y$$r);
    corner = (x$$r, y$r);
  fi
  z$.r{corner - z$.r} ... superness[center,corner]{z$$.r - z$.r}
                      ... {z$$.r - corner}z$$.r
enddef;

vardef super_arc.l(suffix $,$$) =
  % inside of super-ellipse

  pair center, corner;
  if y$ = y$r:
    center = (x$$l, y$l);
    corner = (x$l, y$$l);
  else:
    center = (x$l, y$$l);
    corner = (x$$l, y$l);
  fi
  z$l{corner - z$l} ... superness[center,corner]{z$$l - z$l}
                    ... {z$$l - corner}z$$l
enddef;

vardef pulled_super_arc.r(suffix $,$$)(expr superpull) =
  pair center, corner;

  if y$ = y$r:
    center = (x$$r, y$r);
    corner = (x$r, y$$r);
  else:
    center = (x$r, y$$r);
    corner = (x$$r, y$r);
  fi
  z$r{corner - z$r} ... superness[center,corner]{z$$r - z$r}
                    ... {z$$r - corner}z$$r
enddef;

vardef pulled_super_arc.l(suffix $,$$)(expr superpull) =
  pair center, corner, outer_point;

  if y$ = y$r:
    center = (x$$l, y$l);
    corner = (x$l, y$$l);
    outer_point = superness[(x$$r, y$r), (x$r, y$$r)];
  else:
    center = (x$l, y$$l);
    corner = (x$$l, y$l);
    outer_point = superness[(x$r, y$$r), (x$$r, y$r)];
  fi
  z$l{corner - z$l}
   ... superpull[superness[center,corner], outer_point]{z$$l - z$l}
   ... {z$$l - corner}z$$l
enddef;

vardef pulled_arc@#(suffix $,$$) =
  pulled_super_arc@#($,$$)(superpull)
enddef;

def sim(expr l, r) =
     ( 0/26[l, r] - 1/3equal_spread * dir ((angle (r-l) + 90) mod 180))
  .. ( 1/26[l, r])
  .. ( 5/26[l, r] + 1/3equal_spread * dir ((angle (r-l) + 90) mod 180))
  .. (13/26[l, r])
  .. (21/26[l, r] - 1/3equal_spread * dir ((angle (r-l) + 90) mod 180))
  .. (25/26[l, r])
  .. (26/26[l, r] + 1/3equal_spread * dir ((angle (r-l) + 90) mod 180))
enddef;

def prec(expr l, r, spread) =
     (r - 1/2spread * dir (angle (r-l) + 90)){dir (angle (r-l) + 140)}
  .. {dir (angle (r-l) + 180)}l{dir (angle (r-l))}
  .. {dir (angle (r-l) + 40)}(r + 1/2spread * dir (angle (r-l) + 90));
enddef;

def subset(expr l, r, spread) =
     (r - 1/2spread * dir (angle (r-l) + 90))
  -- (1/3[l, r] - 1/2spread * dir (angle (r-l) + 90)){l - r}
  .. l
  .. (1/3[l, r] + 1/2spread * dir (angle (r-l) + 90)){r - l}
  .. (r + 1/2spread * dir (angle (r-l) + 90))
enddef;

def smile(expr sign, l, r, spread, round_smile) =
  if round_smile:
       (l + sign * 1/2spread * dir (angle (r-l) + 90))
    .. {r - l}(1/2[l,r] - sign * 1/2spread * dir (angle (r-l) + 90)){r - l}
    .. (r + sign * 1/2spread * dir (angle (r-l) + 90))
  else:
       (l + sign * 1/2spread * dir (angle (r-l) + 90))
    -- (1/2[l,r] - sign * 1/2spread * dir (angle (r-l) + 90))
    -- (r + sign * 1/2spread * dir (angle (r-l) + 90))
  fi
enddef;

def stroke_through(expr pos, spread) =
  begingroup;
    stroke_len := 1/2spread / cosd 15;

    pickup stroke_pen;
    draw (pos + stroke_len * dir 75) -- (pos - stroke_len * dir 75);
  endgroup;
enddef;

def draw_product(expr centre, width, height, sign, thick) =
  thin  := 1/2thick;

  z1 - z0 = z3 - z2 = width * dir 0;
  z2 - z0 = sign * height * dir 90;

  1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

  x0 := hround (x0 - 0.5);
  x1 := hround (x1 + 0.5);
  x2 := hround (x2 - 0.5);
  x3 := hround (x3 + 0.5);

  z4 = 1/3[z0,z1];
  z5 = 2/3[z0,z1];

  x4 := hround (x4 + 0.5);
  x5 := hround (x5 - 0.5);

  z6 = 1/2[z0,z4] + sign * max (1/8height, 3/2thin) * dir 90;
  z7 = 1/2[z1,z5] + sign * max (1/8height, 3/2thin) * dir 90;

  z8 = z6 + sign * min (3/4height, height - 3thin) * dir 90;
  z9 = z7 + sign * min (3/4height, height - 3thin) * dir 90;

  penpos 0(thin, sign * 90);
  penpos 1(thin, sign * 90);
  penpos 2(thin, sign * 90);
  penpos 3(thin, sign * 90);
  penpos 4(thin, sign * 90);
  penpos 5(thin, sign * 90);
  penpos 6(thick, 0);
  penpos 7(thick, 0);
  penpos 8(thick, 0);
  penpos 9(thick, 0);

  x6l := hround (x6l - 0.5);
  x6r := hround (x6r + 0.5);
  x7l := hround (x7l - 0.5);
  x7r := hround (x7r + 0.5);
  x8l := hround (x8l - 0.5);
  x8r := hround (x8r + 0.5);
  x9l := hround (x9l - 0.5);
  x9r := hround (x9r + 0.5);

  y10 = y11 = y2r - sign * 1/2[thin,thick];
  x10 = x6r;
  x11 = x7l;

  z10a = z10 - sign * min (1/20height, 4/5sign * (y10 - y9)) * dir 90;
  z10b = z10 + 1/20height * dir 0;
  z11a = z11 - sign * min (1/20height, 4/5sign * (y10 - y9)) * dir 90;
  z11b = z11 - 1/20height * dir 0;

  fill z0l -- z0r{dir 0}   .. {sign * dir 90}z6l -- z6r{sign * dir -90} .. {dir 0}z4r   -- z4l -- cycle;
  fill z1l -- z1r{dir 180} .. {sign * dir 90}z7r -- z7l{sign * dir -90} .. {dir 180}z5r -- z5l -- cycle;
  fill z2r -- z2l{dir 0} .. {sign * dir -90}z8l -- z8r -- z10a{sign * dir 90} .. {dir 0}z10b --
       z11b{dir 0} .. {sign * dir -90}z11a -- z9l -- z9r{sign * dir 90} .. z3l -- z3r -- cycle;
  fill z6l -- z8l -- z8r -- z6r -- cycle;
  fill z7l -- z9l -- z9r -- z7r -- cycle;

  penlabels(0,1,2,3,4,5,6,7,8,9,10,11,10a,10b,11a,11b);
enddef;

def draw_integral(suffix $)(expr scale, center) =
  thick := 2rule_thickness * sqrt (sqrt scale);
  thin  := 1/2thick;

  penpos0$(4/5thick, 0);
  penpos1$(4/5thick, 0);
  penpos2$(5/11thick, -90);
  penpos3$(4/5thick, 0);
  penpos4$(5/11thick, -90);

  z0$ = 1/2[z1$,z3$] = 1/2[z2$,z4$];
  z1$ - z3$ = whatever * dir 80;
  z2$ - z4$ = whatever * dir 70;

  x0$l = xpart centre;
  top y2$ = h;
  bot y4$ = -d;
  y1$ = 1/2[y0$,y2$];

  penpos5$(2/3thick,-135);
  penpos6$(2/3thick,-135);
  y5$ = 1/9[y2$, y1$];
  x5$ = 8/5[x1$r, x2$r];
  y6$ = 1/9[y4$, y3$];
  x6$ = 8/5[x3$l, x4$l];

  x2$r := floor   min (x2$r, x5$r);
  x4$l := ceiling max (x4$l, x6$l);

  x5$r := ceiling x5$r + 1;
  y5$r := ceiling y5$r;
  x6$l := floor   x6$l - 1;
  y6$l := floor   y6$l;

  if abs (angle (z5$r - z2$r)) < 55:
    fill z5$l .. z2$l{left} .. {z3$-z1$}z1$l -- z3$l{z3$-z1$} .. tension 1.5 .. z4$l{left} .. z6$l -- z6$r
      .. z4$r{right} .. {z1$-z3$}z3$r -- z1$r{z1$-z3$} .. tension 1.5 .. z2$r{right} .. z5$r -- cycle;
  else:
    z7$ = z2$r + whatever * dir -30 = whatever[z5$l, z5$r];
    z8$ = z4$l + whatever * dir -30 = whatever[z6$l, z6$r];

    fill z5$l .. z2$l{left} .. {z3$-z1$}z1$l -- z3$l{z3$-z1$} .. tension 1.5 .. z4$l .. z8$ -- z6$r
      .. z4$r{right} .. {z1$-z3$}z3$r -- z1$r{z1$-z3$} .. tension 1.5 .. z2$r .. z7$ -- cycle;
  fi;

%  fill circle(z5$, 1/3thick);
%  fill circle(z6$, 1/3thick);

  penlabels(0$,1$,2$,3$,4$,5$,6$);
enddef;

def ppos_cut(suffix $)(expr a, b) =
  ppos_cut_scaled($)(a, b, 1);
enddef;

def ppos_cut_scaled(suffix $)(expr a, b, scale) =
  if sind(a-b) = 0 :
    penpos$(rule_thickness*scale,0);
  else:
    penpos$(rule_thickness*scale/abs(sind(a-b)),b);
  fi
enddef;

def line_path(suffix $, $$)(text lpath)=
  path lpath;
  penpos$(rule_thickness,angle(z$-z$$)+90); penpos$$(rule_thickness,angle(z$-z$$)+90);
  lpath := stroke z$e .. z$$e;
  penlabels($,$$)
enddef;

def line_scaled_path(suffix $, $$)(expr scale)(text lpath)=
  path lpath;
  penpos$(rule_thickness*scale,angle(z$-z$$)+90); penpos$$(rule_thickness*scale,angle(z$-z$$)+90);
  lpath := stroke z$e .. z$$e;
  penlabels($,$$)
enddef;


def draw_line(suffix $, $$)=
  line_path($, $$)(lpath);
  fill lpath;
enddef;

def draw_line_ec(suffix $, $$)=
  z$a  = z$  + 1/2rule_thickness*dir(angle(z$-z$$));
  z$$a = z$$ + 1/2rule_thickness*dir(angle(z$$-z$));
  penpos$a(rule_thickness,angle(z$-z$$)+90); penpos$$a(rule_thickness,angle(z$-z$$)+90);
  penstroke z$a.e .. z$$a.e;
  penlabels($a,$$a)
enddef;


def draw_line_scaled(suffix $, $$)(expr s)=
  penpos$(s*rule_thickness,angle(z$-z$$)+90); penpos$$(s*rule_thickness,angle(z$-z$$)+90);
  penstroke z$e .. z$$e;
  penlabels($,$$)
enddef;

def draw_line_ec_scaled(suffix $, $$)(expr s)=
  z$a  = z$  + 1/2rule_thickness*dir(angle(z$-z$$));
  z$$a = z$$ + 1/2rule_thickness*dir(angle(z$$-z$));
  penpos$a(s*rule_thickness,angle(z$-z$$)+90); penpos$$a(s*rule_thickness,angle(z$-z$$)+90);
  penstroke z$a.e .. z$$a.e;
  penlabels($a,$$a)
enddef;

def draw_line_cut(suffix $, $$)=
  if (abs(angle(z$-z$$))<45) or (abs(angle(z$-z$$))>135) :
    ppos_cut($)(angle(z$-z$$),90);
    ppos_cut($$)(angle(z$-z$$),90);
  else:
    ppos_cut($)(angle(z$-z$$),0);
    ppos_cut($$)(angle(z$-z$$),0);
  fi
  penstroke z$e .. z$$e;
  penlabels($,$$)
enddef;

def draw_line_cut_ec(suffix $, $$)=
  if (abs(angle(z$-z$$))<45) or (abs(angle(z$-z$$))>135) :
    z$a  = z$  - 1/2rule_thickness*((z$$-z$) dotprod left)/length((z$$-z$) dotprod left)*left;
    z$$a = z$$ + 1/2rule_thickness*((z$$-z$) dotprod left)/length((z$$-z$) dotprod left)*left;
    ppos_cut($a)(angle(z$-z$$),90);
    ppos_cut($$a)(angle(z$-z$$),90);
  else:
    z$a  = z$  - 1/2rule_thickness*((z$$-z$) dotprod up)/length((z$$-z$) dotprod up)*up;
    z$$a = z$$ + 1/2rule_thickness*((z$$-z$) dotprod up)/length((z$$-z$) dotprod up)*up;
    ppos_cut($a)(angle(z$-z$$),0);
    ppos_cut($$a)(angle(z$-z$$),0);
  fi
  penstroke z$a.e .. z$$a.e;
  penlabels($a,$$a)
enddef;

def draw_prec(suffix $,$$,$$$)(expr l, r, spread) =
  z$ = r - 1/2spread * dir (angle (r-l) + 90);
  z$$ = l;
  z$$$ = (r + 1/2spread * dir (angle (r-l) + 90));

  if (angle(l-r)>0) :
    penpos$(rule_thickness, (angle (r-l) + 140) - 90);
    penpos$$$(rule_thickness, (angle (r-l) + 40) + 90);
    penpos$$(rule_thickness,angle(z$$$-z$));
  else:
    penpos$(rule_thickness, (angle (r-l) + 140) + 90);
    penpos$$$(rule_thickness, (angle (r-l) + 40) - 90);
    penpos$$(rule_thickness,angle(z$-z$$$));
  fi
  
  penstroke z$e{dir (angle (r-l) + 140)}
    .. {dir (angle (r-l) + 180)}z$$e;

  penstroke z$$e{dir (angle (r-l))}
    .. {dir (angle (r-l) + 40)}z$$$e;

  penlabels($,$$,$$$);
enddef;

def draw_prec_cut(suffix $,$$,$$$)(expr l, r, spread) =
  z$ = r - 1/2spread * dir (angle (r-l) + 90);
  z$$ = l;
  z$$$ = (r + 1/2spread * dir (angle (r-l) + 90));

  if (angle(l-r)>0) :
    ppos_cut($)(50+angle(z$$$-z$),angle(z$$$-z$));
    ppos_cut($$$)(50+angle(z$$$-z$),angle(z$$$-z$));
    penpos$$(rule_thickness,angle(z$$$-z$));
  else:
    ppos_cut($)(50+angle(z$-z$$$),angle(z$-z$$$));
    ppos_cut($$$)(50+angle(z$-z$$$),angle(z$-z$$$));
    penpos$$(rule_thickness,angle(z$-z$$$));
  fi
  
  penstroke z$e{dir (angle (r-l) + 140)}
    .. {dir (angle (r-l) + 180)}z$$e;

  penstroke z$$e{dir (angle (r-l))}
    .. {dir (angle (r-l) + 40)}z$$$e;

  penlabels($,$$,$$$);
enddef;

def draw_prec_cut_ec(suffix $,$$,$$$)(expr l, r, spread) =
  z$ = r - 1/2spread * dir (angle (r-l) + 90) - 1/2rule_thickness * (l-r)/length(l-r) ;
  z$$ = l + 1/2rule_thickness * (l-r)/length(l-r) ;
  z$$$ = (r + 1/2spread * dir (angle (r-l) + 90)) - 1/2rule_thickness * (l-r)/length(l-r) ;

  if (angle(l-r)>0) :
    ppos_cut($)(50+angle(z$$$-z$),angle(z$$$-z$));
    ppos_cut($$$)(50+angle(z$$$-z$),angle(z$$$-z$));
    penpos$$(rule_thickness,angle(z$$$-z$));
  else:
    ppos_cut($)(50+angle(z$-z$$$),angle(z$-z$$$));
    ppos_cut($$$)(50+angle(z$-z$$$),angle(z$-z$$$));
    penpos$$(rule_thickness,angle(z$-z$$$));
  fi
  
  penstroke z$e{dir (angle (r-l) + 140)}
    .. {dir (angle (r-l) + 180)}z$$e;

  penstroke z$$e{dir (angle (r-l))}
    .. {dir (angle (r-l) + 40)}z$$$e;

  penlabels($,$$,$$$);
enddef;


% left, middle, right
def draw_arrow(suffix $,$$,$$$) = 
  penpos$(rule_thickness,angle(z$$-z$)-90);
  penpos$$$(rule_thickness,angle(z$$$-z$$)+90);

  penpos$$(rule_thickness,angle(z$$$-z$));
  
  penstroke z$e .. z$$e;
  penstroke z$$e .. z$$$e;

  penlabels($,$$,$$$)
enddef;

def arrow_path(suffix $,$$,$$$)(text P) =
  path a,b;
  penpos$(rule_thickness,angle(z$$-z$)-90);
  penpos$$$(rule_thickness,angle(z$$$-z$$)+90);

  penpos$$(rule_thickness,angle(z$$$-z$));
  
  a:=stroke z$$e .. z$e;
  b:=stroke z$$e .. z$$$e;
  find_outlines(b,a)(P);
  penlabels($,$$,$$$);
enddef;


def draw_arrow_point(suffix $,$$,$$$,#) = 
  numeric s,t;
  penpos$(rule_thickness,angle(z$$-z$)-90);
  penpos$$$(rule_thickness,angle(z$$$-z$$)+90);

  penpos$$(rule_thickness,angle(z$$$-z$));
  
  penstroke z$e .. z$$e;
  penstroke z$$e .. z$$$e;

  z# = t[z$$l,z$l];
  z# = s[z$$r,z$$$r];
  fill z$$l -- z$$r -- z# -- cycle;
  
  penlabels($,$$,$$$,#)
enddef;


% left, middle, right
def draw_arrow_cut(suffix $,$$,$$$) = 
  draw_arrow_cut_scaled($,$$,$$$)(1); 
enddef;

% left, middle, right
def draw_arrow_cut_ec(suffix $,$$,$$$) = 
  z$a   = z$   + 1/2rule_thickness*dir(angle(1/2[z$,z$$$]-z$$));
  z$$a  = z$$  - 1/2rule_thickness*dir(angle(1/2[z$,z$$$]-z$$));
  z$$$a = z$$$ + 1/2rule_thickness*dir(angle(1/2[z$,z$$$]-z$$));
  draw_arrow_cut_scaled($a,$$a,$$$a)(1); 
enddef;


% left, middle, right
def draw_arrow_cut_scaled(suffix $,$$,$$$)(expr scale) = 
  %penpos$(rule_thickness,angle(z$$$-z$));
  %penpos$$$(rule_thickness,angle(z$$$-z$));

  ppos_cut_scaled($)(angle(z$$-z$),angle(z$$$-z$),scale);
  ppos_cut_scaled($$$)(angle(z$$-z$$$),angle(z$$$-z$),scale);
  
  ppos_cut_scaled($$)(angle(z$$-z$),angle(z$$$-z$),scale);
  %penpos$$(rule_thickness,angle(z$$$-z$));
  
  penstroke z$e .. z$$e;
  penstroke z$$e .. z$$$e;

  penlabels($,$$,$$$)
enddef;

def draw_subset(suffix $)(expr l, r, spread) =
  z$[1] = r - 1/2spread * dir (angle (r-l) + 90) + 1/2rule_thickness * dir angle(r-l);
  z$[2] = 1/3[l, r] - 1/2spread * dir (angle (r-l) + 90);
  penpos$[1](rule_thickness,angle (r-l)-90); penpos$[2](rule_thickness,angle (r-l)-90);

  z$[3] = l;
  penpos$[3](rule_thickness,angle (r-l)-180);

  z$[4] = 1/3[l, r] + 1/2spread * dir (angle (r-l) + 90);
  z$[5] = r + 1/2spread * dir (angle (r-l) + 90) + 1/2rule_thickness * dir angle(r-l);
  penpos$[4](rule_thickness,angle (r-l)+90);  penpos$[5](rule_thickness,angle (r-l)+90);
  
  penstroke z$[1]e .. z$[2]e{l - r} .. {(l-r) rotated -90}z$[3]e{(l-r) rotated -90} ..
    {r-l}z$[4]e .. z$[5]e;
  penlabels($[1],$[2],$[3],$[4],$[5]);
enddef;

def draw_triangle(suffix $)(expr centre, size, agl) =
  triangle_pos($)(centre, size, agl, 1);
  penstroke z$[1]e .. z$[2]e;
  penstroke z$[3]e .. z$[1]e;
  penstroke z$[2]e .. z$[3]e;
enddef;

def draw_triangle_scaled(suffix $)(expr centre, size, agl, scale) =
  triangle_pos($)(centre, size, agl, scale);
  penstroke z$[1]e .. z$[2]e;
  penstroke z$[3]e .. z$[1]e;
  penstroke z$[2]e .. z$[3]e;
enddef;

def fill_triangle(suffix $)(expr centre, size, agl) =
  triangle_pos($)(centre, size, agl,1);
  fill z$[1]r -- z$[2]r -- z$[3]r -- cycle;
enddef;

def triangle_pos(suffix $)(expr centre, size, agl, scale) =
  z$[1] = centre + size * dir agl;
  z$[2] = centre + size * dir (agl + 120);
  z$[3] = centre + size * dir (agl + 240);

  penpos$[1](scale*rule_thickness/sind(30),agl);
  penpos$[2](scale*rule_thickness/sind(30),agl+120);
  penpos$[3](scale*rule_thickness/sind(30),agl+240);

  penlabels($[1],$[2],$[3]);
enddef;

def draw_circle(suffix $)(expr centre, radius) =
  circle_pos($)(centre, radius, 1);
  penstroke z$[1]e .. z$[2]e .. z$[3]e .. z$[4]e .. cycle;
enddef;

def draw_circle_scaled(suffix $)(expr centre, radius, scale) =
  circle_pos($)(centre, radius, scale);
  penstroke z$[1]e .. z$[2]e .. z$[3]e .. z$[4]e .. cycle;
enddef;

def fill_circle(suffix $)(expr centre, radius) =
  circle_pos($)(centre, radius, 1);
  fill z$[1] .. z$[2] .. z$[3] .. z$[4] .. cycle;
enddef;

def fill_circle_out(suffix $)(expr centre, radius) =
  circle_pos($)(centre, radius, 1);
  fill z$[1]r .. z$[2]r .. z$[3]r .. z$[4]r .. cycle;
enddef;


def circle_pos(suffix $)(expr centre, radius, scale) =
  z$[1] = centre + radius * dir   0;
  z$[2] = centre + radius * dir  90;
  z$[3] = centre + radius * dir 180;
  z$[4] = centre + radius * dir 270;
  penpos$[1](rule_thickness*scale,  0);
  penpos$[2](rule_thickness*scale, 90);
  penpos$[3](rule_thickness*scale,180);
  penpos$[4](rule_thickness*scale,270);

  penlabels($[1],$[2],$[3],$[4]);
enddef;

  
def draw_square(suffix $)(expr centre, size, angle) =
  square_pos($)(centre, size, angle);
  penstroke z$[1]e -- z$[2]e  -- z$[3]e -- z$[4]e -- cycle;
enddef;

def fill_square(suffix $)(expr centre, size, angle) =
  square_pos($)(centre, size, angle);
  fill z$[1] -- z$[2] -- z$[3] -- z$[4] -- cycle;
enddef;

def fill_square_out(suffix $)(expr centre, size, angle) =
  square_pos($)(centre, size, angle);
  fill z$[1]r -- z$[2]r -- z$[3]r -- z$[4]r -- cycle;
enddef;

def square_pos(suffix $)(expr centre, size, angle) =
  z$[1] = centre + sqrt(2) * size * dir (angle +  45);
  z$[2] = centre + sqrt(2) * size * dir (angle + 135);
  z$[3] = centre + sqrt(2) * size * dir (angle + 225);
  z$[4] = centre + sqrt(2) * size * dir (angle + 315);

  penpos$[1](sqrt(2)*rule_thickness, (angle +  45));
  penpos$[2](sqrt(2)*rule_thickness, (angle + 135));
  penpos$[3](sqrt(2)*rule_thickness, (angle + 225));
  penpos$[4](sqrt(2)*rule_thickness, (angle + 315));

  penlabels($[1],$[2],$[3],$[4]);
enddef;

def reg_poly_points_p(suffix $)(expr n, centre, radius, agl,scale) =
  for i = 0 upto n-1:
    z$[i] = centre + radius * dir (agl + i/n * 360);
    penpos$[i](rule_thickness*scale,angle(z$[i] - centre));
    penlabels($[i]);
  endfor;
enddef;

def draw_smile(suffix $)(expr sign, l, r, spread, round_smile) =
 % if round_smile:
    z$[1] = (l + sign * 1/2spread * dir (angle (r-l) + 90));
    z$[2] = (1/2[l,r] - sign * 1/2spread * dir (angle (r-l) + 90));
    z$[3] = (r + sign * 1/2spread * dir (angle (r-l) + 90));

    penpos$[1](rule_thickness,angle(z$[1]-z$[2])+90);
    penpos$[2](rule_thickness,angle(r-l)-90);
    penpos$[3](rule_thickness,angle(z$[3]-z$[2])-90);

    penlabels($[1],$[2],$[3]);
    penstroke z$[1]e .. {r - l}z$[2]e{r - l} .. z$[3]e;
  % else:
  %      (l + sign * 1/2spread * dir (angle (r-l) + 90))
  %   -- (1/2[l,r] - sign * 1/2spread * dir (angle (r-l) + 90))
  %   -- (r + sign * 1/2spread * dir (angle (r-l) + 90))
 % fi

enddef;
    
def draw_sim(suffix $)(expr l, r) =
  z$1 =  0/26[l, r] - 1/3equal_spread * dir ((angle (r-l) + 90) mod 180);
  z$2 =  1/26[l, r];
  z$3 =  5/26[l, r] + 1/3equal_spread * dir ((angle (r-l) + 90) mod 180);
  z$4 = 13/26[l, r];
  z$5 = 21/26[l, r] - 1/3equal_spread * dir ((angle (r-l) + 90) mod 180);
  z$6 = 25/26[l, r];
  z$7 = 26/26[l, r] + 1/3equal_spread * dir ((angle (r-l) + 90) mod 180);

  penpos$1(rule_thickness,angle(z$2-z$1)+90);
  penpos$2(rule_thickness,(angle(z$3-z$2)+angle(z$2-z$1))/2+90);
  penpos$4(rule_thickness,(angle(z$5-z$4)+angle(z$4-z$3))/2+90);
  penpos$6(rule_thickness,(angle(z$7-z$6)+angle(z$6-z$5))/2+90);
  penpos$7(rule_thickness,angle(z$7-z$6)+90);

  if (cosd(angle(l-r))<=0):
    penpos$3(rule_thickness,(angle(z$4-z$3)+angle(z$3-z$2))/2+90);
    penpos$5(rule_thickness,(angle(z$6-z$5)+angle(z$5-z$4))/2+90);
  else:
    penpos$3(rule_thickness,(angle(z$4-z$3)+angle(z$3-z$2))/2-90);
    penpos$5(rule_thickness,(angle(z$6-z$5)+angle(z$5-z$4))/2-90);
  fi
  
  penstroke z$1.e .. z$2.e .. z$3.e .. z$4.e .. z$5.e .. z$6.e .. z$7.e;
  
  penlabels($1,$2,$3,$4,$5,$6,$7);
enddef;

def draw_stroke_through(suffix $,#)(expr pos, spread) =
  begingroup;
    stroke_len := 1/2spread / cosd 15;

    z$ = pos + stroke_len * dir 75; z# = pos - stroke_len * dir 75;
    draw_line_scaled($,#)(stroke_through_thickness_factor);
    penlabels($,#);
  endgroup;
enddef;

def draw_stroke_through_arrow(suffix $,#)(expr pos, alpha, spread)(text angles) =
  begingroup;
    stroke_dir := arrow_dir + select(alpha/45)(angles);
    stroke_len := 1/2spread / sind (stroke_dir - arrow_dir);

    z$ = pos + stroke_len * dir stroke_dir; z# = pos - stroke_len * dir stroke_dir;
    draw_line_scaled($,#)(stroke_through_thickness_factor);
    penlabels($,#);
  endgroup;
enddef;

% left half of an arrow head
def draw_arrowhead_left(suffix $)(expr pos, angle, spread) =
  z$[10]=pos;
  z$[1]=pos - 3/4spread * dir angle + spread/2 * dir (angle + 90);
  z$[2]=pos - 1/2rule_thickness*dir(angle + 90);
  % cos(atan(2/3)) = 0.83205
  penpos$[10](rule_thickness/0.83205,angle+90);
  penpos$[1](rule_thickness/0.83205,angle+90);

  z$[3]=whatever[z$[10].r,z$[1].r];
  z$[3]=z$[2] + whatever* dir angle;

  z$[4]= ((z$[2] -- z$[2]- 3/4spread * dir angle) intersectionpoint (z$[10].l .. z$[1].l));

  % these points are fine but point of arrow is not where meant to be
  % so shift all points
  z$[5] = pos + 1/2rule_thickness*(dir angle + dir (angle-90));
  z$[6] = z$[1] + z$[5] - z$[3]; penpos$[6](rule_thickness/0.83205,angle+90);
  z$[7] = z$[4] + z$[5] - z$[3];

  fill z$[5] -- z$[6].r -- z$[6].l -- z$[7] -- cycle;

    % point to dock line
  z$[0] = z$[7] + 1/2rule_thickness*dir (angle+90);
  
  penlabels($[5],$[6],$[7]);

%  penstroke z$[0]e .. z$[1]e;
 % penstroke z$[1]e{dir (angle - 50)}  .. {dir (angle -  50)}z$[2]e;
enddef;

% right half of an arrow head
def draw_arrowhead_right(suffix $)(expr pos, angle, spread) =
  z$[10]=pos;
  z$[1]=pos - 3/4spread * dir angle + spread/2 * dir (angle - 90);
  z$[2]=pos - 1/2rule_thickness*dir(angle - 90);
  % cos(atan(2/3)) = 0.83205

  penpos$[10](rule_thickness/0.83205,angle+90);
  penpos$[1](rule_thickness/0.83205,angle+90);

  z$[3]=whatever[z$[10].l,z$[1].l];
  z$[3]=z$[2] + whatever* dir angle;

  z$[4]= ((z$[2] -- z$[2]- 3/4spread * dir angle) intersectionpoint (z$[10].r .. z$[1].r));

  % these points are fine but point of arrow is not where meant to be
  % so shift all points
  z$[5] = pos + 1/2rule_thickness*(dir angle + dir (angle+90));
  z$[6] = z$[1] + z$[5] - z$[3]; penpos$[6](rule_thickness/0.83205,angle+90);
  z$[7] = z$[4] + z$[5] - z$[3];
  
  fill z$[5] -- z$[6].l -- z$[6].r -- z$[7] -- cycle;

      % point to dock line
  z$[0] = z$[7] + 1/2rule_thickness*dir (angle-90);

  penlabels($[0],$[1],$[3],$[4]);
enddef;

% the whole arrow head
def arrowhead_bo_path(suffix $)(expr pos, angle, spread)(text ap) =
  path ap;
  z$[10] = pos - 1/2rule_thickness * dir angle;
  z$[1] = z$[10] - 3/4spread * dir angle + spread/2 * dir (angle + 90);
  z$[2] = z$[10] - 3/4spread * dir angle + spread/2 * dir (angle - 90);
  
  % cos(atan(2/3)) = 0.83205
  penpos$[10](rule_thickness/0.55470,angle);
  penpos$[1](rule_thickness/0.83205,angle+90);
  penpos$[2](rule_thickness/0.83205,angle-90);

  ap := stroke z$[1].e -- z$[10].e -- z$[2].e;

  z$[0] = z$[10];
  
  %  penlabels($[0],$[1],$[3],$[4]);
enddef;

% the whole arrow head
def arrowhead_fo_path(suffix $)(expr pos, angle, spread)(text ap) =
  path ap;
  z$[10]r = pos + 1/2rule_thickness * dir angle;
  z$[1]  = z$[10] - 3/4spread * dir angle + spread/2 * dir (angle + 90);
  z$[2]  = z$[10] - 3/4spread * dir angle + spread/2 * dir (angle - 90);
  
  % cos(atan(2/3)) = 0.83205
  penpos$[10](rule_thickness/0.55470,angle);
  penpos$[1](rule_thickness/0.83205,angle+90);
  penpos$[2](rule_thickness/0.83205,angle-90);

  ap := stroke z$[1].e -- z$[10].e -- z$[2].e;

  z$[0] = z$[10];
  
  %  penlabels($[0],$[1],$[3],$[4]);
enddef;

% the whole arrow head
def draw_arrowhead_bo(suffix $)(expr pos, angle, spread) =
  arrowhead_bo_path($)(pos, angle, spread) (ahead);
  fill ahead;
enddef;

% the whole arrow head
def draw_arrowhead_fo(suffix $)(expr pos, angle, spread) =
  arrowhead_fo_path($)(pos, angle, spread) (ahead);
  fill ahead;
enddef;


% the whole arrow head
def draw_arrowhead_fo_add(suffix $)(expr pos, angle, spread) =
  arrowhead_fo_path($)(pos, angle, spread) (ahead);
  z$[3] = z$[0];
  z$[4] = z$[0] - 1/2spread * dir angle;

  penpos$[3](rule_thickness, angle+90);
  penpos$[4](rule_thickness, angle+90);

  if known ps_output:
    path q,o;
    q :=stroke z$[4].e -- z$[3].e;
    find_outlines(q,ahead)(o);
    fill o[1];
  else:
    fill ahead;
    penstroke z$[4].e -- z$[3].e;
  fi
  %  penlabels($[0],$[1],$[3],$[4]);
enddef;

def draw_half_circle(suffix $)(expr centre, radius, angle) =
  z$[1] = centre + radius * dir (angle +   0);
  z$[2] = centre + radius * dir (angle +  45);
  z$[3] = centre + radius * dir (angle +  90);
  z$[4] = centre + radius * dir (angle + 135);
  z$[5] = centre + radius * dir (angle + 180);

  penpos$[1](rule_thickness,angle +   0 );
  penpos$[2](rule_thickness,angle +  45 );
  penpos$[3](rule_thickness,angle +  90 );
  penpos$[4](rule_thickness,angle + 135 );
  penpos$[5](rule_thickness,angle + 180 );
  
  penstroke z$[1]e{dir (angle +  90)} ... z$[2]e{dir (angle + 135)} ...
    z$[3]e{dir (angle + 180)} ... z$[4]e{dir (angle + 225)} ...
    z$[5]e{dir (angle + 270)};
  penlabels($[1],$[2],$[3],$[4],$[5]);
enddef;
